{"version":3,"file":"docs-ThemingExtensions-mdx.f11e9ded.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://lightning-ui-docs/../../@lightningjs/ui-components/src/docs/ThemingExtensions.mdx","webpack://lightning-ui-docs/../../../node_modules/@storybook/addon-docs/node_modules/@mdx-js/react/lib/index.js","webpack://lightning-ui-docs/../../../node_modules/@storybook/core/dist/components/ sync","webpack://lightning-ui-docs/../../../node_modules/memoizerific/ sync"],"sourcesContent":["\nimport React from 'react';\n\n/*prettier-ignore*/\n/*\nCopyright 2023 Comcast Cable Communications Management, LLC\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\nSPDX-License-Identifier: Apache-2.0\n\\*/\nimport {Fragment as _Fragment, jsx as _jsx, jsxs as _jsxs} from \"react/jsx-runtime\";\nimport {useMDXComponents as _provideComponents} from \"/home/runner/work/Lightning-UI-Components/Lightning-UI-Components/node_modules/@storybook/addon-docs/dist/shims/mdx-react-shim.mjs\";\nimport {Meta} from '@storybook/blocks';\nimport ExtensionProgressBar from '../assets/images/ExtensionProgressBar.png';\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    blockquote: \"blockquote\",\n    code: \"code\",\n    h1: \"h1\",\n    h2: \"h2\",\n    h3: \"h3\",\n    h5: \"h5\",\n    p: \"p\",\n    pre: \"pre\",\n    strong: \"strong\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [\"\\n\", \"\\n\", \"\\n\", _jsx(Meta, {\n      title: \"Docs / Theming/ Extensions\"\n    }), \"\\n\", _jsx(_components.h1, {\n      id: \"extensions\",\n      children: \"Extensions\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The component library cannot account for every design imaginable. That's where extensions come in. Extensions are exported functions that return a class. They allow users to add functionality to components without having to make the components from scratch themselves.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For example, let's say a \", _jsx(_components.code, {\n        children: \"Tile\"\n      }), \" element needs to have a certain feature. An extension containing that feature can be created and added to the \", _jsx(_components.code, {\n        children: \"Tile\"\n      }), \" element without the developer having to make an entirely new component.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Overall, extensions make LUI as flexible with \", _jsx(_components.a, {\n        href: \"?path=/docs/docs-theming-overview--docs\",\n        children: \"theming\"\n      }), \" as possible.\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"withextensions-mixin\",\n      children: [_jsx(_components.code, {\n        children: \"withExtensions\"\n      }), \" Mixin\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Extensions follow a similar structure as mixins. Mixins return classes with added functionality without needing to create a new, standalone class that inherits from another. They make it so that functions that are often used can be quickly applied across components just by nesting the component in a mixin. In this way, mixins also simplify the amount of code in the component(s).\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"withExtensions\"\n      }), \" mixin, specifically, contains functions that allow for the use of extensions in every component. In order to take advantage of the ability to use extensions, components must have the \", _jsx(_components.code, {\n        children: \"withExtensions\"\n      }), \" mixin applied to it.\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"Note:\"\n        }), \" All LUI components already have the \", _jsx(_components.code, {\n          children: \"withExtensions\"\n        }), \" mixin applied.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The example below shows how the \", _jsx(_components.code, {\n        children: \"withExtensions\"\n      }), \" mixin is used on the \", _jsx(_components.code, {\n        children: \"ProgressBar\"\n      }), \" component.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js\",\n        children: \"export default withExtensions(ProgressBar);\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"To reiterate, extensions are a way to modify any component at runtime using ES6 class inheritance patterns and apply that change easily across your entire application.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"how-to-apply-an-extension\",\n      children: \"How to Apply an Extension\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"1-create-the-extension\",\n      children: \"1. Create the extension\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For instance:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js\",\n        children: \"export default function textAdditionExtension(Base) {\\n  return class extends Base {\\n    _update() {\\n      this.patch({\\n        ExtensionAdded: {\\n          type: TextBox,\\n          content: 'Extension Applied!',\\n          style: {\\n            offsetY: 50\\n          }\\n        }\\n      });\\n      super._update();\\n    }\\n  };\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This example code extension will add a text box displaying 'Extension Applied!' to all the components the extension is applied to.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"2-determine-which-themes-and-components-to-apply-the-extension-to\",\n      children: \"2. Determine which theme(s) and component(s) to apply the extension to\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now that we have the extension defined, we can apply the extension to components in our desired theme(s). We'll have to generate an array of objects containing the component(s) we want to add the extension to as well as the extension itself.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Let's say we have a theme called 'customTheme' and we want to apply our newly created extension, \", _jsx(_components.code, {\n        children: \"textAdditionExtension\"\n      }), \", to the \", _jsx(_components.code, {\n        children: \"ProgressBar\"\n      }), \" component. Our theme file where we define all our theme properties might look something like:\"]\n    }), \"\\n\", _jsx(_components.h5, {\n      id: \"customthemeindexjs\",\n      children: \"./customTheme/index.js\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js\",\n        children: \"import textAdditionExtension from '../../extensions/textAddition.extension';\\n\\nexport default {\\n  name: 'customTheme',\\n  ...\\n  extension: [\\n    {\\n      targetComponent: ['ProgressBar'],\\n      extension: textAdditionExtension\\n    }\\n  ]\\n};\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"Note: Extensions can be written in a file on its own.\\nIn doing so, you would just need to export the array and import the file into the theme rather than the specific extension displayed above.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"3-make-sure-to-call-contextsettheme-or-contextupdatetheme\",\n      children: [\"3. Make sure to call \", _jsx(_components.code, {\n        children: \"context.setTheme()\"\n      }), \" or \", _jsx(_components.code, {\n        children: \"context.updateTheme()\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Although we've added the extension to our theme, it isn't truly applied until we set the theme that has our extension or call \", _jsx(_components.code, {\n        children: \"updateTheme\"\n      }), \" on the extension property.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"That is, we must call:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js\",\n        children: \"context.setTheme(customTheme);\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"or\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js\",\n        children: \"context.updateTheme({ extensions: textAdditionExtension });\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"After doing all three steps, for our example, we should see a \", _jsx(_components.code, {\n        children: \"ProgressBar\"\n      }), \" with text below it saying 'Extension Applied!' as displayed below:\"]\n    }), \"\\n\", _jsx(\"img\", {\n      src: ExtensionProgressBar,\n      alt: \"Progress Bar with 'Extension Applied!' text below\",\n      width: \"600\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"use-cases-outside-of-ui-enhancements\",\n      children: \"Use Cases Outside of UI Enhancements\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"There are many use cases for extensions since it's all about adding functionality to different components. This provides a fully customizable experience.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Below are some specific examples that extensions can be used for:\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"metrics\",\n      children: \"Metrics\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Extensions can be used to toggle metrics collection.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For example, let's say we want to collect how often users focus on certain movie \", _jsx(_components.code, {\n        children: \"Tiles\"\n      }), \" to understand the general genre of interest among the audience. We can write all the functionality of detecting how many times the \", _jsx(_components.code, {\n        children: \"Tile\"\n      }), \" elements are being put into focus state and apply that to the \", _jsx(_components.code, {\n        children: \"Tile\"\n      }), \" components. As easy as we can apply the extension, we can just as easily remove the extension when we're done with metrics collection.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"ab-testing\",\n      children: \"A/B Testing\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Another potential use of extensions is for A/B testing. If you're unfamiliar with A/B testing, it is also known as \\\"split testing.\\\" It's a randomized experiment that explores how users view two or more variations of a component at the same time (often a control - the original and the variation).\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For our case, extensions can help us do A/B testing on, say, a new feature of \", _jsx(_components.code, {\n        children: \"Tile\"\n      }), \" or a potential new look to \", _jsx(_components.code, {\n        children: \"Tile\"\n      }), \". For example, let's say we want to gauge if making the \", _jsx(_components.code, {\n        children: \"Tile\"\n      }), \" components more vibrant in color would increase engagement. We can patch an update to the \", _jsx(_components.code, {\n        children: \"Tile\"\n      }), \"'s colors in our extension. During testing, we can then apply the extension at theme level to random users and test to see if there are more interactions with the vibrant colored \", _jsx(_components.code, {\n        children: \"Tile\"\n      }), \" components.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If we find through A/B testing, the results are not in favor of the vibrant colored \", _jsx(_components.code, {\n        children: \"Tile\"\n      }), \" components, we can easily discard our extension and move forward since we didn't have to touch the core code.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"things-to-keep-in-mind\",\n      children: \"Things to Keep in Mind\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"super_update\",\n      children: _jsx(_components.code, {\n        children: \"super._update()\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If we consider extensions as the child of the existing component it builds off, the \", _jsx(_components.code, {\n        children: \"super\"\n      }), \" keyword allows us to access the properties and methods in the existing/parent component. The \", _jsx(_components.code, {\n        children: \"_update\"\n      }), \" method is an extremely important lifecycle event since it ensures everything is up to date. Together, \", _jsx(_components.code, {\n        children: \"super._update()\"\n      }), \" grants us access to the entire \", _jsx(_components.code, {\n        children: \"_update\"\n      }), \" lifecycle event of the parent component.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For that reason, most often, we would want to include \", _jsx(_components.code, {\n        children: \"super._update()\"\n      }), \" within our extension's \", _jsx(_components.code, {\n        children: \"_update\"\n      }), \" lifecycle event. This way we ensure our extension functions are applying to the most up to date component.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"On the other hand, if we want to update the existing functions within the \", _jsx(_components.code, {\n        children: \"_update\"\n      }), \" lifecycle event in the parent component, then that's when we wouldn't call \", _jsx(_components.code, {\n        children: \"super._update()\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"_extensioncleanup\",\n      children: _jsx(_components.code, {\n        children: \"_extensionCleanup()\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"_extensionCleanup\"\n      }), \" method is used to remove extension-specific logic when swapping themes or changing extensions at runtime. This method is automatically called by the \", _jsx(_components.code, {\n        children: \"withExtensions\"\n      }), \" mixin when \\\"resetting\\\" a component.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"An example is provided below, specifically for our \", _jsx(_components.code, {\n        children: \"textAdditionExtension\"\n      }), \":\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js\",\n        children: \"_extensionCleanup() {\\n  this.patch({ ExtensionAdded: undefined });\\n  super._extensionCleanup && super._extensionCleanup();\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"order-matters\",\n      children: \"Order Matters!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Extensions are applied top to bottom. That is, the first extension in the extensions array will be added first, then the second one, and so on.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js\",\n        children: \"import { focusRingExtension } from '../../extensions/FocusRing.extension';\\nimport textAdditionExtension from '../../extensions/textAddition.extension';\\n\\nexport default [\\n  {\\n    targetComponent: ['ProgressBar'],\\n    extension: focusRingExtension\\n  },\\n  {\\n    targetComponent: ['ProgressBar'],\\n    extension: textAdditionExtension\\n  }\\n];\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In this example, the \", _jsx(_components.code, {\n        children: \"focusRingExtension\"\n      }), \" would be applied to the \", _jsx(_components.code, {\n        children: \"ProgressBar\"\n      }), \" component first and then the \", _jsx(_components.code, {\n        children: \"textAdditionExtension\"\n      }), \" would be applied.\"]\n    })]\n  });\n}\nexport default function MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\n","/**\n * @typedef {import('mdx/types.js').MDXComponents} MDXComponents\n * @typedef {import('react').Component<{}, {}, unknown>} Component\n * @typedef {import('react').ReactNode} ReactNode\n */\n\n/**\n * @callback MergeComponents\n *   Custom merge function.\n * @param {Readonly<MDXComponents>} currentComponents\n *   Current components from the context.\n * @returns {MDXComponents}\n *   Additional components.\n *\n * @typedef Props\n *   Configuration for `MDXProvider`.\n * @property {ReactNode | null | undefined} [children]\n *   Children (optional).\n * @property {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that creates them (optional).\n * @property {boolean | null | undefined} [disableParentContext=false]\n *   Turn off outer component context (default: `false`).\n */\n\nimport React from 'react'\n\n/** @type {Readonly<MDXComponents>} */\nconst emptyComponents = {}\n\nconst MDXContext = React.createContext(emptyComponents)\n\n/**\n * Get current components from the MDX Context.\n *\n * @param {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that creates them (optional).\n * @returns {MDXComponents}\n *   Current components.\n */\nexport function useMDXComponents(components) {\n  const contextComponents = React.useContext(MDXContext)\n\n  // Memoize to avoid unnecessary top-level context changes\n  return React.useMemo(\n    function () {\n      // Custom merge via a function prop\n      if (typeof components === 'function') {\n        return components(contextComponents)\n      }\n\n      return {...contextComponents, ...components}\n    },\n    [contextComponents, components]\n  )\n}\n\n/**\n * Provider for MDX context.\n *\n * @param {Readonly<Props>} properties\n *   Properties.\n * @returns {JSX.Element}\n *   Element.\n * @satisfies {Component}\n */\nexport function MDXProvider(properties) {\n  /** @type {Readonly<MDXComponents>} */\n  let allComponents\n\n  if (properties.disableParentContext) {\n    allComponents =\n      typeof properties.components === 'function'\n        ? properties.components(emptyComponents)\n        : properties.components || emptyComponents\n  } else {\n    allComponents = useMDXComponents(properties.components)\n  }\n\n  return React.createElement(\n    MDXContext.Provider,\n    {value: allComponents},\n    properties.children\n  )\n}\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = \"../../../node_modules/@storybook/core/dist/components sync recursive\";\nmodule.exports = webpackEmptyContext;","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = \"../../../node_modules/memoizerific sync recursive\";\nmodule.exports = webpackEmptyContext;"],"names":[],"sourceRoot":""}