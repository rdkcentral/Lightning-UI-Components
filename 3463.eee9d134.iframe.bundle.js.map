{"version":3,"file":"3463.eee9d134.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;AC3CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqDA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AAIA;AAAA;AAAA;AAAA;AAQA;AACA;AAAA;AANA;AACA;AACA;AAAA;AAAA;AAAA;AAYA;AACA;AAAA;AANA;AACA;AACA;AAAA;AAAA;AAAA;AAOA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAEA;AAGA;AAAA;AAAA;AAAA;AAGA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AAMA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAOA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAQA;AAIA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AA9lBA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAGA;AAcA;AAAA;AAAA;AAAA;AAGA;AASA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAfA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA","sources":["webpack://lightning-ui-docs/../../@lightningjs/ui-components/src/components/Artwork/Artwork.styles.js","webpack://lightning-ui-docs/../../@lightningjs/ui-components/src/components/Artwork/Artwork.js","webpack://lightning-ui-docs/../../@lightningjs/ui-components/src/components/Gradient/Gradient.styles.js","webpack://lightning-ui-docs/../../@lightningjs/ui-components/src/components/Gradient/Gradient.js"],"sourcesContent":["/**\n * Copyright 2023 Comcast Cable Communications Management, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport const base = theme => ({\n  animationBlurEntrance: theme.animation.utilityEntrance,\n  animationBlurExit: theme.animation.utilityExit,\n  animationComponentEntrance: theme.animation.utilityEntrance,\n  animationGradientEntrance: theme.animation.utilityEntrance,\n  animationGradientExit: theme.animation.utilityExit,\n  animationImageScaleEntrance: theme.animation.standardEntrance,\n  animationImageScaleExit: theme.animation.standardEntrance,\n  blur: 4,\n  centerImageRadius: theme.radius.md,\n  fallbackSrc: undefined,\n  fillColor: theme.color.overlay,\n  gradientColor: theme.color.material,\n  imageScale: undefined,\n  imageScalePivotX: 0.5,\n  imageScalePivotY: 0.5,\n  padding: theme.spacer.md,\n  radius: 0,\n  zIndexSet: {\n    image: 1,\n    blur: 2,\n    centerImage: 3,\n    fill: 4,\n    gradient: 5,\n    foreground: 6\n  }\n});\n","/**\n * Copyright 2023 Comcast Cable Communications Management, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport lng from '@lightningjs/core';\nimport { getValidColor, reduceFraction } from '../../utils';\nimport Base from '../Base';\nimport Gradient from '../Gradient';\nimport * as styles from './Artwork.styles.js';\nimport { context } from '../../globals';\nimport CustomImageTexture from '../../textures/CustomImageTexture';\n\nexport default class Artwork extends Base {\n  static get __componentName() {\n    return 'Artwork';\n  }\n\n  static get __themeStyle() {\n    return styles;\n  }\n\n  static get properties() {\n    return [\n      'blur',\n      'fallbackSrc',\n      'foregroundHeight',\n      'foregroundSrc',\n      'foregroundWidth',\n      'gradient',\n      'format',\n      'src',\n      'fill',\n      'shouldScale',\n      'srcCallback',\n      'srcCallbackAspectRatios'\n    ];\n  }\n\n  static get tags() {\n    return [\n      'Blur',\n      'CenterImage',\n      'FillColor',\n      'ForegroundImage',\n      'Gradient',\n      'Image',\n      'Item'\n    ];\n  }\n\n  static get aliasProperties() {\n    return [\n      { prev: 'foregroundH', curr: 'foregroundHeight' },\n      { prev: 'foregroundW', curr: 'foregroundWidth' }\n    ];\n  }\n\n  static _template() {\n    return {\n      rtt: true,\n      Image: {}\n    };\n  }\n\n  get _shouldBlur() {\n    const shouldBur = this._blur || this._hasCenterImage;\n    this._Image.rtt = shouldBur; // rtt can cause a performance hit. Remove if not needed on Image\n    return shouldBur; // Artwork should always use blur when circleImage is set to true\n  }\n\n  get _hasCenterImage() {\n    return (\n      -1 < ['circle', 'square'].indexOf(this.format) ||\n      ('contain' === this.format && !this._aspectRatioEqual)\n    );\n  }\n\n  set w(v) {\n    super.w = v;\n    this._componentSrc = this._generatePromise();\n  }\n\n  get w() {\n    return super.w;\n  }\n\n  set h(v) {\n    super.h = v;\n    this._componentSrc = this._generatePromise();\n  }\n\n  get h() {\n    return super.h;\n  }\n\n  get _actualAspectRatio() {\n    if (!this.w || !this.h) return null;\n    return reduceFraction(`${this.w}/${this.h}`).replace('/', 'x');\n  }\n\n  get _supportedAspectRatioHeights() {\n    return this.srcCallbackAspectRatios.map(ratio => {\n      const [rw, rh] = ratio.split('x').map(v => parseInt(v));\n      const calcHeight = (this.w / rw) * rh;\n      return calcHeight;\n    });\n  }\n\n  get _closestSupportedAspectRatio() {\n    const closest = this._supportedAspectRatioHeights.reduce((prev, curr) =>\n      Math.abs(curr - this.h) < Math.abs(prev - this.h) ? curr : prev\n    );\n    return this.srcCallbackAspectRatios[\n      this._supportedAspectRatioHeights.indexOf(closest)\n    ];\n  }\n\n  get _processedImageSrc() {\n    let src = this.src || this.fallbackSrc;\n    if (\n      src !== this.fallbackSrc &&\n      this.srcCallback &&\n      typeof this.srcCallback === 'function'\n    ) {\n      src = this.srcCallback({\n        closestAspectRatio: this._closestSupportedAspectRatio,\n        aspectRatio: this._actualAspectRatio,\n        src: this.src,\n        w: this.w,\n        h: this.h\n      });\n    }\n\n    return src && src.then ? src : Promise.resolve(src);\n  }\n\n  get _gradientPatch() {\n    return {\n      alpha: !this._Gradient && this.shouldSmooth ? 0.001 : 1,\n      style: {\n        gradientColor: getValidColor(this.style.gradientColor)\n      },\n      h: this.h + 4,\n      type: Gradient,\n      w: this.w + 4,\n      x: -2,\n      y: -2,\n      zIndex: this.core.findZContext().zIndex + this.style.zIndexSet.gradient\n    };\n  }\n\n  _construct() {\n    super._construct();\n    this._srcCallbackAspectRatios = ['16x9', '3x4', '4x3', '2x1', '1x1'];\n  }\n\n  _setSrc(v) {\n    this._componentSrc = this._generatePromise();\n    return v;\n  }\n\n  _getFallbackSrc() {\n    return this._fallbackSrc || (this.style && this.style.fallbackSrc);\n  }\n\n  _generatePromise() {\n    // When a new src, w, or h value is added promises need to be reset\n    let resolvePromise, rejectPromise;\n    const complete = new Promise(function (resolve, reject) {\n      resolvePromise = resolve;\n      rejectPromise = reject;\n    });\n    return {\n      complete,\n      resolve: resolvePromise,\n      reject: rejectPromise\n    };\n  }\n\n  _setup() {\n    this.alpha = 0.001; // Hide on first load to stop flash of un-styled content on first creation\n    this._componentSrc = this._generatePromise(); // Initialize loading promises\n    this._aspectRatioEqual = false;\n    // Wait for _Image to be added to the tree to set listeners\n    this._Image.on('txLoaded', this._resolveLoading.bind(this));\n    this._Image.on('txError', this._rejectLoading.bind(this));\n  }\n\n  _resolveLoading() {\n    this._aspectRatioEqual = this._Image.texture.source\n      ? parseFloat(this.finalW / this.finalH).toFixed(2) ===\n        parseFloat(\n          this._Image.texture.source.w / this._Image.texture.source.h\n        ).toFixed(2)\n      : false;\n    this._componentSrc.resolve && this._componentSrc.resolve();\n    this.signal('imageLoaded');\n  }\n\n  _rejectLoading(error) {\n    this._componentSrc.reject && this._componentSrc.reject(error);\n  }\n\n  async _update() {\n    this._updateRadius();\n    this._updateGradient();\n\n    await this._updateImage();\n    this._updateFillColor();\n    this._updateForegroundImage();\n    if (!this.src) {\n      this._showComponent(); // Ensure that component displays even in the case that src is not set\n      return;\n    }\n    try {\n      // These actions are dependent on the image loading so we wait for the process to complete\n      await this._componentSrc.complete;\n      await this._updateCenterImage();\n      this._updateBlur();\n      // After everything is setup fade in the Artwork component for the first time\n      this._showComponent();\n      this._updateScale();\n    } catch (e) {\n      this._handleImageLoadError();\n    }\n    if (this.shouldSmooth === undefined) this.shouldSmooth = true;\n  }\n\n  _updateScale() {\n    if (this.shouldScale) {\n      let imageScale;\n      switch (typeof this.style.imageScale) {\n        case 'function':\n          imageScale = this.style.imageScale(this.w);\n          break;\n        case 'number':\n          imageScale = this.style.imageScale;\n          break;\n        default:\n          imageScale = 1;\n      }\n\n      this._Image.smooth = {\n        pivotX: this.style.imageScalePivotX,\n        pivotY: this.style.imageScalePivotY,\n        scale: [\n          imageScale,\n          this._Image.scale < imageScale\n            ? this.style.animationImageScaleEntrance\n            : this.style.animationImageScaleExit\n        ]\n      };\n    } else {\n      const scale = 1;\n      this._Image.smooth = {\n        scale: [scale, this.style.animationImageScaleExit]\n      };\n    }\n  }\n\n  _handleImageLoadError() {\n    if (this.src === this.fallbackSrc) return;\n    context.error(`Image ${this._src} failed to load`);\n    if (this.fallbackSrc && this.fallbackSrc !== this.src) {\n      this.src = this.fallbackSrc;\n    }\n  }\n\n  _showComponent() {\n    this.smooth = {\n      alpha: [1, this.style.animationComponentEntrance]\n    };\n  }\n\n  async _updateForegroundImage() {\n    if (!this._foregroundSrc) {\n      if (this._ForegroundImage) {\n        this.patch({\n          ForegroundImage: undefined\n        });\n      }\n      return;\n    }\n\n    const foregroundImagePatch = {\n      mount: 0.5,\n      x: this.w / 2,\n      y: this.h / 2,\n      zIndex: this.core.findZContext().zIndex + this.style.zIndexSet.foreground,\n      texture: {\n        type: CustomImageTexture,\n        src: this._foregroundSrc,\n        hasAlpha: true\n      }\n    };\n\n    if (this.foregroundWidth && this.foregroundHeight) {\n      // The image size is already known so we can just patch it\n      foregroundImagePatch.h = this.foregroundHeight;\n      foregroundImagePatch.w = this.foregroundWidth;\n\n      this.patch({\n        ForegroundImage: foregroundImagePatch\n      });\n    } else if (this.foregroundWidth || this.foregroundHeight) {\n      // Load the image to get the aspect ratio before showing\n      this.patch({\n        ForegroundImage: { ...foregroundImagePatch, alpha: 0.001 }\n      });\n\n      this._ForegroundImage.once('txLoaded', () => {\n        const imageW = this._ForegroundImage.texture.getRenderWidth();\n        const imageH = this._ForegroundImage.texture.getRenderHeight();\n        this._ForegroundImage.patch({\n          alpha: 1,\n          w: this.foregroundHeight\n            ? this.foregroundHeight * (imageW / imageH)\n            : this.foregroundWidth,\n          h: this.foregroundWidth\n            ? this.foregroundWidth * (imageH / imageW)\n            : this.foregroundHeight\n        });\n      });\n    }\n\n    this.patch({\n      ForegroundImage: foregroundImagePatch\n    });\n  }\n\n  _updateBlur() {\n    if (\n      (!this._shouldBlur ||\n        (this._Image &&\n          this._Image.texture &&\n          this._Image.texture.src === this.fallbackSrc)) &&\n      this._Blur\n    ) {\n      // Remove Blur element as it is not longer required\n      if (this.shouldSmooth) {\n        this._Blur._getTransition('alpha').once('finish', () => {\n          // Clean up gradient after animation is complete\n          this.patch({ Blur: undefined });\n        });\n        this._Blur.smooth = {\n          alpha: [0, this.style.animationBlurExit]\n        };\n      } else {\n        this.patch({\n          Blur: undefined\n        });\n      }\n      return;\n    }\n    // Create/update the Blur element\n    if (!this._srcFailed && this._shouldBlur) {\n      this.patch({\n        Blur: {\n          alpha: !this._Blur && this.shouldSmooth ? 0.001 : 1, // If the Blur element already exists there is no need to fade it in again\n          amount: this.style.blur,\n          zIndex: this.core.findZContext().zIndex + this.style.zIndexSet.blur,\n          content: {\n            Image: {\n              h: this.h,\n              texture: this._Image.getTexture(),\n              w: this.w\n            }\n          },\n          h: this.h,\n          rtt: true,\n          type: lng.components.FastBlurComponent,\n          w: this.w\n        }\n      });\n\n      if (this._Blur.alpha < 1) {\n        this._Blur.smooth = {\n          alpha: [1, this.style.animationBlurEntrance]\n        };\n      }\n    }\n  }\n\n  _updateCenterImage() {\n    if (this.format === 'contain') {\n      this._updateFormatContain();\n    } else if (this.format === 'circle' || this.format === 'square') {\n      this._updateFormatSquareCircle();\n    } else if (this._CenterImage) {\n      // Remove the center image element if no longer required\n      this.patch({\n        CenterImage: undefined\n      });\n    }\n  }\n\n  async _updateFormatContain() {\n    if (\n      (this._CenterImage && this._CenterImage.mode !== this.format) ||\n      this.src === this.fallbackSrc ||\n      this._aspectRatioEqual\n    ) {\n      // Make sure previous mode is propertly cleaned up\n      this.patch({\n        CenterImage: undefined\n      });\n\n      if (this.src === this.fallbackSrc || this._aspectRatioEqual) {\n        this._Image.alpha = 1;\n        return; // If is fallback image or the aspect ratio already fits the space there is no need to proceed\n      }\n    }\n\n    let imageW;\n    let imageH;\n\n    const ratioW = Math.abs(\n      this._Image.texture.source.w / this._Image.texture.source.h\n    );\n\n    const ratioH = Math.abs(\n      this._Image.texture.source.h / this._Image.texture.source.w\n    );\n\n    if (this._Image.texture.source.w < this._Image.texture.source.h) {\n      // portrait\n      if (this.h * ratioW < this.w) {\n        // make sure it is set to show 100% height\n        imageW = this.h * ratioW;\n        imageH = this.h;\n      } else {\n        // make 100% width\n\n        imageW = this.w;\n        imageH = this.w * ratioH;\n      }\n    } else if (this._Image.texture.source.w > this._Image.texture.source.h) {\n      // landscape\n      if (this.w * ratioH < this.h) {\n        // make sure it is set to show 100% w\n        imageW = this.w;\n        imageH = this.w * ratioH;\n      } else {\n        // make 100% width\n        imageW = this.h * ratioW;\n        imageH = this.h;\n      }\n    } else {\n      // render a square\n      imageW = Math.min(this.w, this.h);\n      imageH = imageW;\n    }\n\n    const src = await this._processedImageSrc;\n\n    this.patch({\n      CenterImage: {\n        format: this.format,\n        mount: 0.5,\n        w: imageW,\n        h: imageH,\n        x: this.w / 2,\n        y: this.h / 2,\n        zIndex:\n          this.core.findZContext().zIndex + this.style.zIndexSet.centerImage,\n        texture: {\n          src,\n          resizeMode: {\n            h: imageH,\n            type: 'cover',\n            w: imageW\n          },\n          type: CustomImageTexture\n        }\n      }\n    });\n  }\n\n  _updateFormatSquareCircle() {\n    if (\n      (this._CenterImage && this._CenterImage.mode !== this.format) ||\n      this.src === this.fallbackSrc\n    ) {\n      // Make sure previous mode is properly cleaned up\n      this.patch({\n        CenterImage: undefined\n      });\n      if (this.src === this.fallbackSrc) return;\n    }\n    const imageSize = Math.min(this.w, this.h) - this.style.padding * 2;\n    this.patch({\n      CenterImage: {\n        format: this.format,\n        h: imageSize,\n        shader: {\n          radius:\n            'circle' === this.format\n              ? imageSize / 2\n              : this.style.centerImageRadius,\n          type: lng.shaders.RoundedRectangle\n        },\n        w: imageSize,\n        zIndex:\n          this.core.findZContext().zIndex + this.style.zIndexSet.centerImage,\n        Image: {\n          h: imageSize,\n          mount: 0.5,\n          rtt: true, // Required for shader to work\n          w: imageSize,\n          x: this.w / 2,\n          y: this.h / 2,\n          texture: {\n            src: this._Image.texture.src,\n            resizeMode: {\n              h: imageSize,\n              type: 'cover',\n              w: imageSize\n            },\n            type: CustomImageTexture\n          }\n        }\n      }\n    });\n  }\n\n  _updateGradient() {\n    if (!this.gradient) {\n      if (this._Gradient) {\n        // Cleanup previous gradient\n        if (this.shouldSmooth) {\n          this._Gradient._getTransition('alpha').once('finish', () => {\n            // Remove gradient if no longer required\n            const transition =\n              this._Gradient && this._Gradient._getTransition('alpha');\n            if (!this.gradient && transition && transition.p === 1)\n              this.patch({ Gradient: undefined });\n          });\n          this._Gradient.patch(this._gradientPatch); // Make sure any mode updates are patched ex.radius changes when focused/unfocused\n          this._Gradient.smooth = {\n            alpha: [0, this.style.animationGradientExit]\n          };\n        } else {\n          this.patch({ Gradient: undefined });\n        }\n      }\n      return;\n    }\n\n    this._createGradient();\n  }\n\n  _createGradient() {\n    this.patch({\n      Gradient: this._gradientPatch // Allows for an easier way to extend and replace the gradient\n    });\n    if (this.shouldSmooth) {\n      this.applySmooth(this._Gradient, {\n        alpha: [1, this.style.animationGradientEntrance]\n      });\n    }\n  }\n\n  async _updateImage() {\n    this._aspectRatioEqual = false; // Set this back to false since we will not know the aspect ratio until after the image has loaded\n\n    if (!this._processedImageSrc) {\n      if (this._Image) {\n        this._Image.texture = undefined;\n      }\n      return;\n    }\n\n    const src = await this._processedImageSrc;\n\n    this._Image.patch({\n      alpha:\n        this.src !== this.fallbackSrc && (this._blur || this._hasCenterImage)\n          ? 0.001\n          : 1, // Prevent image from flashing on first load if mode requires a center image or blur is true\n      h: this.h,\n      texture: {\n        type: CustomImageTexture,\n        src,\n        resizeMode: { type: 'cover', w: this.w, h: this.h }\n      },\n      w: this.w,\n      zIndex: this.core.findZContext().zIndex + this.style.zIndexSet.image\n    });\n  }\n\n  _updateFillColor() {\n    if (!this.fill) {\n      this.patch({\n        FillColor: undefined\n      });\n    } else {\n      this.patch({\n        FillColor: {\n          rect: true,\n          w: this.w,\n          h: this.h,\n          color: this.style.fillColor,\n          zIndex: 5\n        }\n      });\n    }\n  }\n\n  _updateRadius() {\n    // Add shader to all items in component if greater than 0, remove shader otherwise.\n    this.patch(\n      this.style.radius\n        ? {\n            shader: {\n              type: lng.shaders.RoundedRectangle,\n              radius: this.style.radius\n            }\n          }\n        : { shader: undefined }\n    );\n  }\n}\n","/**\n * Copyright 2023 Comcast Cable Communications Management, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport const base = theme => ({\n  gradientTop: theme.color.fillTransparent,\n  radius: theme.radius.none\n});\n\nexport const tone = theme => ({\n  neutral: { gradientColor: theme.color.material },\n  inverse: { gradientColor: theme.color.fillNeutral },\n  brand: { gradientColor: theme.color.fillBrand }\n});\n","/**\n * Copyright 2023 Comcast Cable Communications Management, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport lng from '@lightningjs/core';\nimport Base from '../Base';\nimport * as styles from './Gradient.styles.js';\n\nexport default class Gradient extends Base {\n  static get __componentName() {\n    return 'Gradient';\n  }\n\n  static get __themeStyle() {\n    return styles;\n  }\n\n  _update() {\n    this.patch({\n      rect: true,\n      rtt: true,\n      colorTop: this.style.gradientTop,\n      colorBottom: this.style.gradientColor,\n      texture: lng.Tools.getRoundRect(this.w, this.h, this.style.radius)\n    });\n  }\n}\n"],"names":[],"sourceRoot":""}